
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  
    <title>Redis的List，从linkedlist和ziplist再到quicklist | Liexing&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="liexing">
    

    
    <meta name="description" content="List的底层编码及演进Redis对外暴露最基本的5种结构，比如String、List、Set、ZSet和Hash，而每种结构在底层又能通过不同的数据结构来实现。在service.h中定义了底层使用的数据结构： 1234567891011121314/* Objects encoding. Some kind of objects like Strings and Hashes can be *">
<meta name="keywords" content="笔记,redis,数据结构,quicklist,ziplist">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis的List，从linkedlist和ziplist再到quicklist">
<meta property="og:url" content="http://blog.liexing.me/2019/12/28/from-ziplist-linkedlist-to-quicklist/index.html">
<meta property="og:site_name" content="Liexing&#39;s Blog">
<meta property="og:description" content="List的底层编码及演进Redis对外暴露最基本的5种结构，比如String、List、Set、ZSet和Hash，而每种结构在底层又能通过不同的数据结构来实现。在service.h中定义了底层使用的数据结构： 1234567891011121314/* Objects encoding. Some kind of objects like Strings and Hashes can be *">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://blog.liexing.me/images/from-ziplist-linkedlist-to-quicklist/15773759260279.jpg">
<meta property="og:image" content="http://blog.liexing.me/images/from-ziplist-linkedlist-to-quicklist/15774500192728.jpg">
<meta property="og:image" content="http://blog.liexing.me/images/from-ziplist-linkedlist-to-quicklist/15774517236868.jpg">
<meta property="og:image" content="http://blog.liexing.me/images/from-ziplist-linkedlist-to-quicklist/15774679538508.jpg">
<meta property="og:updated_time" content="2023-01-20T15:04:29.741Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis的List，从linkedlist和ziplist再到quicklist">
<meta name="twitter:description" content="List的底层编码及演进Redis对外暴露最基本的5种结构，比如String、List、Set、ZSet和Hash，而每种结构在底层又能通过不同的数据结构来实现。在service.h中定义了底层使用的数据结构： 1234567891011121314/* Objects encoding. Some kind of objects like Strings and Hashes can be *">
<meta name="twitter:image" content="http://blog.liexing.me/images/from-ziplist-linkedlist-to-quicklist/15773759260279.jpg">
<meta name="twitter:creator" content="@scusjs">

    
    <link rel="alternative" href="/atom.xml" title="Liexing&#39;s Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/favicon.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/favicon.jpg">
    
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/css/style.css">
</head>
</html>
  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Liexing&#39;s Blog" title="Liexing&#39;s Blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Liexing&#39;s Blog">Liexing&#39;s Blog</a></h1>
				<h2 class="blog-motto"><span id="ones">不疯魔，不成佛</span></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页 | Home</a></li>
					
						<li><a href="/archives">归档 | Archives</a></li>
					
						<li><a href="/about">简介 | About</a></li>
					
					<li>
 					
					<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" autocomplete="off" name="q" maxlength="20" placeholder="搜索" />
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
    
    <article itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/12/28/from-ziplist-linkedlist-to-quicklist/" title="Redis的List，从linkedlist和ziplist再到quicklist" itemprop="url">Redis的List，从linkedlist和ziplist再到quicklist</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="liexing" target="_blank" itemprop="author">liexing</a>
		
  <p class="article-time">
    <time datetime="2019-12-28T15:47:36.000Z" itemprop="datePublished"> 发表于 2019-12-28</time>
<span id="busuanzi_container_page_pv">
  &nbsp<i class="fa fa-eye"></i> <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>
</span>
    
  </p>
</header>

    <div class="article-content">
        
        <div id="toc" class="toc-article">
            <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#List的底层编码及演进"><span class="toc-number">1.</span> <span class="toc-text">List的底层编码及演进</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linkedlist"><span class="toc-number">2.</span> <span class="toc-text">linkedlist</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ziplist"><span class="toc-number">3.</span> <span class="toc-text">ziplist</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QuickList"><span class="toc-number">4.</span> <span class="toc-text">QuickList</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#性能对比"><span class="toc-number">5.</span> <span class="toc-text">性能对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#quicklist的性能"><span class="toc-number">5.1.</span> <span class="toc-text">quicklist的性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linkedlist的性能"><span class="toc-number">5.2.</span> <span class="toc-text">linkedlist的性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ziplist的性能"><span class="toc-number">5.3.</span> <span class="toc-text">ziplist的性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">5.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol>
        
        </div>
        
        <h2 id="List的底层编码及演进"><a href="#List的底层编码及演进" class="headerlink" title="List的底层编码及演进"></a>List的底层编码及演进</h2><p>Redis对外暴露最基本的5种结构，比如String、List、Set、ZSet和Hash，而每种结构在底层又能通过不同的数据结构来实现。在service.h中定义了底层使用的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Objects encoding. Some kind of objects like Strings and Hashes can be</span></span><br><span class="line"><span class="comment"> * internally represented in multiple ways. The 'encoding' field of the object</span></span><br><span class="line"><span class="comment"> * is set to one of this fields for this object. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="comment">/* Encoded as zipmap */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="comment">/* No longer used: old list encoding. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="comment">/* Encoded as linked list of ziplists */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_STREAM 10 <span class="comment">/* Encoded as a radix tree of listpacks */</span></span></span><br></pre></td></tr></table></figure>
<p>对于List，在Redis中的相关代码在<code>t_list.c</code>，在3.0及之前的版本中，对于list的调用为如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (subject-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class="line">    <span class="comment">//something</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (subject-&gt;encoding == REDIS_ENCODING_LINKEDLIST) &#123;</span><br><span class="line">    <span class="comment">//something</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    redisPanic(<span class="string">"Unknown list encoding"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即对于3.0及之前版本，对于list在底层存在两种不同的实现方式，ziplist以及linkedlist，但是在3.2版本开始，对于list的调用变成了如下形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_QUICKLIST) &#123;</span><br><span class="line">    <span class="comment">//something</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    serverPanic(<span class="string">"Unknown list encoding"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，在3.2及之后的版本，Redis使用了quicklist这个新的实现方式来替换以前的ziplist以及linkedlist。</p>
<h2 id="linkedlist"><a href="#linkedlist" class="headerlink" title="linkedlist"></a>linkedlist</h2><p>linkedlist即经典的双链表，其定义在3.0及之前版本的<code>adlist.h</code>文件中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Node, List, and Iterator are the only data structures used currently. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>
<p>每个node包含了三个部分，指向前一个节点和后一个节点的指针，以及一个数据值。而一个list包含了指向首尾的指针、整个list的长度，以及三个函数指针，用来复制节点的值、释放节点的值，以及比较节点内容。</p>
<p><img src="/images/from-ziplist-linkedlist-to-quicklist/15773759260279.jpg" title="linkedlist示意图" alt="linkedlist示意图"><br>即对于每一个节点，value指向robj对象，而robj对象中的ptr指向实际的SDS对象，包含了长度，空余长度，真实字符串+’\0’，对于链表中每增加一个节点，需要实际内容额外42个字节（3.0.6版本，32位）的存储空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_LRU_BITS 24</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> lru:REDIS_LRU_BITS; <span class="comment">/* lru time (relative to server.lruclock) */</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>显然，linkedlist在频繁前后端插入情况下表现良好，但是查找效率比较低，并且比较耗内存。</p>
<h2 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h2><p>在Redis源码中，ziplist的实现在<code>ziplist.c</code>文件中，一开头就介绍了，ziplist是一种特殊编码的节省内存空间的双链表，能以O(1)的时间复杂度在两端<code>push</code>和<code>pop</code>数据，具有如下结构：</p>
<blockquote>
<p><code>&lt;zlbytes&gt;&lt;zltail&gt;&lt;zllen&gt;&lt;entry&gt;&lt;entry&gt;&lt;zlend&gt;</code></p>
</blockquote>
<ul>
<li>zlbytes是一个<code>unsigned integer</code>，保存ziplist占用的总内存空间，在重新分配内存时，借助这个字段可以不用遍历整个ziplist；</li>
<li>zltail是指向最后一个entry的偏移量，这样对于尾部的操作不用去遍历所有entry；</li>
<li>zllen固定两个字节长度，表示entry的数量，最大能表示<code>2^16-2</code>个entry，如果超过了，则其值为<code>2^16-1</code>，需要遍历entry才能知道具体的数量；</li>
<li>zlend固定一个字节，值固定为255，表示ziplist的结尾。</li>
</ul>
<p>zlbytes、zltail、zllen统称为ziplist的header，其空间总占用定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))</span></span><br></pre></td></tr></table></figure>
<p>新建一个空的ziplist的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create a new empty ziplist. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistNew</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bytes = ZIPLIST_HEADER_SIZE+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = zmalloc(bytes);</span><br><span class="line">    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);</span><br><span class="line">    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);</span><br><span class="line">    ZIPLIST_LENGTH(zl) = <span class="number">0</span>;</span><br><span class="line">    zl[bytes<span class="number">-1</span>] = ZIP_END;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>entry的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zlentry</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevrawlensize, prevrawlen;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lensize, len;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> headersize;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line">&#125; zlentry;</span><br></pre></td></tr></table></figure>
<p>prevrawlen和len均采用变长编码的方式来存储数据。</p>
<p>其中prevrawlen表示前一个节点的长度，prevrawlensize用来表示prevrawlen的大小，有1字节和5字节两种。如果prevrawlen小于254字节，则只需要一字节来保存，如果大于等于254字节，则需要5字节保存，第一个字节被置为254，其余4字节用来保存实际长度；len为当前节点长度 lensize为编码len所需的字节大小；headersize为当前节点的header大小；encoding为节点的编码方式；*p为指向节点的指针。</p>
<p>redis通过如下的代码来获取prevrawlen和prevrawlensize。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Encode the length of the previous entry and write it to "p". Return the</span></span><br><span class="line"><span class="comment"> * number of bytes needed to encode this length if "p" is NULL. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipPrevEncodeLength</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (len &lt; ZIP_BIGLEN) ? <span class="number">1</span> : <span class="keyword">sizeof</span>(len)+<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; ZIP_BIGLEN) &#123;</span><br><span class="line">            p[<span class="number">0</span>] = len;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p[<span class="number">0</span>] = ZIP_BIGLEN;</span><br><span class="line">            <span class="built_in">memcpy</span>(p+<span class="number">1</span>,&amp;len,<span class="keyword">sizeof</span>(len));</span><br><span class="line">            memrev32ifbe(p+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+<span class="keyword">sizeof</span>(len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于lensize和len，这二者的值和entry内存储的类型有关。如果存储string，则前两个bit位用来存储string的编码方式，后面跟上实际的长度。如果存储integer，则前两个bit位置为1，随后两个bit位指定integer的类型。具体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">* |<span class="number">00</span>pppppp| - <span class="number">1</span> byte</span><br><span class="line">*      String value with length less than <span class="keyword">or</span> equal to <span class="number">63</span> bytes (<span class="number">6</span> bits).</span><br><span class="line">* |<span class="number">01</span>pppppp|qqqqqqqq| - <span class="number">2</span> bytes</span><br><span class="line">*      String value with length less than <span class="keyword">or</span> equal to <span class="number">16383</span> bytes (<span class="number">14</span> bits).</span><br><span class="line">* |<span class="number">10</span>______|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt| - <span class="number">5</span> bytes</span><br><span class="line">*      String value with length greater than <span class="keyword">or</span> equal to <span class="number">16384</span> bytes.</span><br><span class="line">* |<span class="number">11000000</span>| - <span class="number">1</span> byte</span><br><span class="line">*      Integer encoded as int16_t (2 bytes).</span><br><span class="line">* |<span class="number">11010000</span>| - <span class="number">1</span> byte</span><br><span class="line">*      Integer encoded as int32_t (4 bytes).</span><br><span class="line">* |<span class="number">11100000</span>| - <span class="number">1</span> byte</span><br><span class="line">*      Integer encoded as int64_t (8 bytes).</span><br><span class="line">* |<span class="number">11110000</span>| - <span class="number">1</span> byte</span><br><span class="line">*      Integer encoded as 24 bit signed (3 bytes).</span><br><span class="line">* |<span class="number">11111110</span>| - <span class="number">1</span> byte</span><br><span class="line">*      Integer encoded as 8 bit signed (1 byte).</span><br><span class="line">* |<span class="number">1111</span>xxxx| - (with xxxx between <span class="number">0000</span> <span class="keyword">and</span> <span class="number">1101</span>) immediate <span class="number">4</span> bit integer.</span><br><span class="line">*      Unsigned integer from <span class="number">0</span> to <span class="number">12.</span> The encoded value is actually from</span><br><span class="line">*      <span class="number">1</span> to <span class="number">13</span> because <span class="number">0000</span> <span class="keyword">and</span> <span class="number">1111</span> can <span class="keyword">not</span> be used, so <span class="number">1</span> should be</span><br><span class="line">*      subtracted from the encoded <span class="number">4</span> bit value to obtain the right value.</span><br><span class="line">* |<span class="number">11111111</span>| - End of ziplist.</span><br></pre></td></tr></table></figure>
<p>从<code>ZIP_DECODE_LENGTH</code>可以看出具体的解码过程和每个字段的存储位置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Different encoding/length possibilities */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_STR_MASK 0xc0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_MASK 0x30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_STR_06B (0 &lt;&lt; 6)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_STR_14B (1 &lt;&lt; 6)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_STR_32B (2 &lt;&lt; 6)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Extract the encoding from the byte pointed by 'ptr' and set it into</span></span><br><span class="line"><span class="comment"> * 'encoding'. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_ENTRY_ENCODING(ptr, encoding) do &#123;  \</span></span><br><span class="line">    (encoding) = (ptr[<span class="number">0</span>]); \</span><br><span class="line">    <span class="keyword">if</span> ((encoding) &lt; ZIP_STR_MASK) (encoding) &amp;= ZIP_STR_MASK; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Decode the length encoded in 'ptr'. The 'encoding' variable will hold the</span></span><br><span class="line"><span class="comment"> * entries encoding, the 'lensize' variable will hold the number of bytes</span></span><br><span class="line"><span class="comment"> * required to encode the entries length, and the 'len' variable will hold the</span></span><br><span class="line"><span class="comment"> * entries length. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_DECODE_LENGTH(ptr, encoding, lensize, len) do &#123;                    \</span></span><br><span class="line">    ZIP_ENTRY_ENCODING((ptr), (encoding));                                     \</span><br><span class="line">    <span class="keyword">if</span> ((encoding) &lt; ZIP_STR_MASK) &#123;                                           \</span><br><span class="line">        <span class="keyword">if</span> ((encoding) == ZIP_STR_06B) &#123;                                       \</span><br><span class="line">            (lensize) = <span class="number">1</span>;                                                     \</span><br><span class="line">            (len) = (ptr)[<span class="number">0</span>] &amp; <span class="number">0x3f</span>;                                           \</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((encoding) == ZIP_STR_14B) &#123;                                \</span><br><span class="line">            (lensize) = <span class="number">2</span>;                                                     \</span><br><span class="line">            (len) = (((ptr)[<span class="number">0</span>] &amp; <span class="number">0x3f</span>) &lt;&lt; <span class="number">8</span>) | (ptr)[<span class="number">1</span>];                       \</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == ZIP_STR_32B) &#123;                                  \</span><br><span class="line">            (lensize) = <span class="number">5</span>;                                                     \</span><br><span class="line">            (len) = ((ptr)[<span class="number">1</span>] &lt;&lt; <span class="number">24</span>) |                                         \</span><br><span class="line">                    ((ptr)[<span class="number">2</span>] &lt;&lt; <span class="number">16</span>) |                                         \</span><br><span class="line">                    ((ptr)[<span class="number">3</span>] &lt;&lt;  <span class="number">8</span>) |                                         \</span><br><span class="line">                    ((ptr)[<span class="number">4</span>]);                                                \</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                                                               \</span><br><span class="line">            assert(<span class="literal">NULL</span>);                                                      \</span><br><span class="line">        &#125;                                                                      \</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                                                   \</span><br><span class="line">        (lensize) = <span class="number">1</span>;                                                         \</span><br><span class="line">        (len) = zipIntSize(encoding);                                          \</span><br><span class="line">    &#125;                                                                          \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>对len字段进行计算的过程如下面的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Encode the length 'rawlen' writing it in 'p'. If p is NULL it just returns</span></span><br><span class="line"><span class="comment"> * the amount of bytes required to encode such a length. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipEncodeLength</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding, <span class="keyword">unsigned</span> <span class="keyword">int</span> rawlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> len = <span class="number">1</span>, buf[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ZIP_IS_STR(encoding)) &#123;</span><br><span class="line">        <span class="comment">/* Although encoding is given it may not be set for strings,</span></span><br><span class="line"><span class="comment">         * so we determine it here using the raw length. */</span></span><br><span class="line">        <span class="keyword">if</span> (rawlen &lt;= <span class="number">0x3f</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!p) <span class="keyword">return</span> len;</span><br><span class="line">            buf[<span class="number">0</span>] = ZIP_STR_06B | rawlen;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rawlen &lt;= <span class="number">0x3fff</span>) &#123;</span><br><span class="line">            len += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (!p) <span class="keyword">return</span> len;</span><br><span class="line">            buf[<span class="number">0</span>] = ZIP_STR_14B | ((rawlen &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x3f</span>);</span><br><span class="line">            buf[<span class="number">1</span>] = rawlen &amp; <span class="number">0xff</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len += <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">if</span> (!p) <span class="keyword">return</span> len;</span><br><span class="line">            buf[<span class="number">0</span>] = ZIP_STR_32B;</span><br><span class="line">            buf[<span class="number">1</span>] = (rawlen &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            buf[<span class="number">2</span>] = (rawlen &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            buf[<span class="number">3</span>] = (rawlen &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            buf[<span class="number">4</span>] = rawlen &amp; <span class="number">0xff</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Implies integer encoding, so length is always 1. */</span></span><br><span class="line">        <span class="keyword">if</span> (!p) <span class="keyword">return</span> len;</span><br><span class="line">        buf[<span class="number">0</span>] = encoding;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Store this length at p */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(p,buf,len);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，对于integer编码，长度恒为1，否则读取实际的string的长度值。</p>
<p>而实际上，encoding又是保存在len字段的第一个字节，判断是否是字符串的方法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_STR_MASK 0xc0</span></span><br><span class="line"><span class="comment">/* Macro to determine type */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_IS_STR(enc) (((enc) &amp; ZIP_STR_MASK) &lt; ZIP_STR_MASK)</span></span><br></pre></td></tr></table></figure>
<p>encoding和p表示元素编码和内容，其具体的定义可参考如下函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_16B (0xc0 | 0&lt;&lt;4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_32B (0xc0 | 1&lt;&lt;4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_64B (0xc0 | 2&lt;&lt;4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_24B (0xc0 | 3&lt;&lt;4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_8B 0xfe</span></span><br><span class="line"><span class="comment">/* 4 bit integer immediate encoding */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_IMM_MASK 0x0f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_IMM_MIN 0xf1    <span class="comment">/* 11110001 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_IMM_MAX 0xfd    <span class="comment">/* 11111101 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if string pointed to by 'entry' can be encoded as an integer.</span></span><br><span class="line"><span class="comment"> * Stores the integer value in 'v' and its encoding in 'encoding'. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">zipTryEncoding</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *entry, <span class="keyword">unsigned</span> <span class="keyword">int</span> entrylen, <span class="keyword">long</span> <span class="keyword">long</span> *v, <span class="keyword">unsigned</span> <span class="keyword">char</span> *encoding)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (entrylen &gt;= <span class="number">32</span> || entrylen == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (string2ll((<span class="keyword">char</span>*)entry,entrylen,&amp;value)) &#123;</span><br><span class="line">        <span class="comment">/* Great, the string can be encoded. Check what's the smallest</span></span><br><span class="line"><span class="comment">         * of our encoding types that can hold this value. */</span></span><br><span class="line">        <span class="keyword">if</span> (value &gt;= <span class="number">0</span> &amp;&amp; value &lt;= <span class="number">12</span>) &#123;</span><br><span class="line">            *encoding = ZIP_INT_IMM_MIN+value;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= INT8_MIN &amp;&amp; value &lt;= INT8_MAX) &#123;</span><br><span class="line">            *encoding = ZIP_INT_8B;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= INT16_MIN &amp;&amp; value &lt;= INT16_MAX) &#123;</span><br><span class="line">            *encoding = ZIP_INT_16B;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= INT24_MIN &amp;&amp; value &lt;= INT24_MAX) &#123;</span><br><span class="line">            *encoding = ZIP_INT_24B;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= INT32_MIN &amp;&amp; value &lt;= INT32_MAX) &#123;</span><br><span class="line">            *encoding = ZIP_INT_32B;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *encoding = ZIP_INT_64B;</span><br><span class="line">        &#125;</span><br><span class="line">        *v = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convert a string into a long long. Returns 1 if the string could be parsed</span></span><br><span class="line"><span class="comment"> * into a (non-overflowing) long long, 0 otherwise. The value will be set to</span></span><br><span class="line"><span class="comment"> * the parsed value when appropriate. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">string2ll</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> slen, <span class="keyword">long</span> <span class="keyword">long</span> *value)</span></span>;</span><br></pre></td></tr></table></figure>
<p>显然如上面的描述，对于entrylen&gt;=32不用做处理，接下来设置encoding为具体的值。</p>
<p>对于ziplist的push操作，在<code>ziplistPush</code>中具体定义，简单描述其流程如下：</p>
<ol>
<li>获取指向尾部或者头部节点的指针p；</li>
<li>获取p的prevlensize和prevlen；</li>
<li>通过prevlen以及coding、实际插入数据来计算待插入的节点reqlen；</li>
<li>如不在队尾插入，则需要校验p对应节点的prelen是否够reqlen使用，不够需要扩展，够不进行压缩，防止连锁更新；</li>
<li>更新队尾偏移量；</li>
<li>判断是否需要连锁更新；</li>
<li>保存插入节点内容；</li>
<li>ziplist的长度加一。</li>
</ol>
<p>连锁更新的执行函数以及解释如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* When an entry is inserted, we need to set the prevlen field of the next</span></span><br><span class="line"><span class="comment"> * entry to equal the length of the inserted entry. It can occur that this</span></span><br><span class="line"><span class="comment"> * length cannot be encoded in 1 byte and the next entry needs to be grow</span></span><br><span class="line"><span class="comment"> * a bit larger to hold the 5-byte encoded prevlen. This can be done for free,</span></span><br><span class="line"><span class="comment"> * because this only happens when an entry is already being inserted (which</span></span><br><span class="line"><span class="comment"> * causes a realloc and memmove). However, encoding the prevlen may require</span></span><br><span class="line"><span class="comment"> * that this entry is grown as well. This effect may cascade throughout</span></span><br><span class="line"><span class="comment"> * the ziplist when there are consecutive entries with a size close to</span></span><br><span class="line"><span class="comment"> * ZIP_BIGLEN, so we need to check that the prevlen can be encoded in every</span></span><br><span class="line"><span class="comment"> * consecutive entry.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that this effect can also happen in reverse, where the bytes required</span></span><br><span class="line"><span class="comment"> * to encode the prevlen field can shrink. This effect is deliberately ignored,</span></span><br><span class="line"><span class="comment"> * because it can cause a "flapping" effect where a chain prevlen fields is</span></span><br><span class="line"><span class="comment"> * first grown and then shrunk again after consecutive inserts. Rather, the</span></span><br><span class="line"><span class="comment"> * field is allowed to stay larger than necessary, because a large prevlen</span></span><br><span class="line"><span class="comment"> * field implies the ziplist is holding large entries anyway.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The pointer "p" points to the first entry that does NOT need to be</span></span><br><span class="line"><span class="comment"> * updated, i.e. consecutive fields MAY need an update. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistCascadeUpdate(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p);</span><br></pre></td></tr></table></figure>
<p>如上面的描述，可以得到ziplist的简易示意图如下，每个节点是单独的entry，每个entry中一个字段表示前一个entry的长度（长度小于254时采用一个字节编码，否则采用5个字节），一个encoding字段保存当前节点的编码方式和数据长度，content保存着entry的具体数据，可以是字符数组或整数，如果是整数且在0-12之间则不再保存content。</p>
<p><img src="/images/from-ziplist-linkedlist-to-quicklist/15774500192728.jpg" title="ziplist示意图" alt="ziplist示意图"></p>
<p>ziplist可以很方便的拿到头节点或者尾节点，由于每个节点都保存前一个节点的长度，因此对于任意节点可以方便的前后遍历。相比linkedlist，除了链表结构节省少量空间外，每个entry可以节省大量的额外内存（最大额外空间才10字节，对于不大于12的正整数，甚至不用content空间来进行存储）。对于主要是pop或push并且每个元素长度不大的场景来说，ziplist相比于linkedlist有较大的优势。</p>
<p>但是如前面所说，通过<code>ZIP_BIGLEN</code>即<code>254</code>这个分界点来确认prevlen的长度，如果每一个节点的长度原本都是253，如果在头部插入时下一个节点的prevlen需要扩展，则会导致整个ziplist都进行更新。在删除时也可能出现类似情况。但是这种情况出现的概率不大，并且在使用ziplist时，entry总量不大，因此可以忽略不计。</p>
<p>ziplist的弊端也很明显了，对于较多的entry或者entry长度较大时，需要大量的连续内存，并且节省的空间比例相对不在占优势，就可以考虑使用其他结构了。</p>
<p><img src="/images/from-ziplist-linkedlist-to-quicklist/15774517236868.jpg" title="redis中list配置" alt="redis中list配置"><br>如图所示是3.0.6版本redis中的默认值，即单个entry长度官方默认要求小于64时才使用ziplist，否则使用其他底层结构；entry数量也有限制，一般要求在512个(hash和list)或者128个（zset）之内才使用。</p>
<h2 id="QuickList"><a href="#QuickList" class="headerlink" title="QuickList"></a>QuickList</h2><p>前面介绍的两种结构，一种耗内存但是能应付数据较大（数量或者单个的长度）的情况，但是插入和删除成本低，而另一个则在小规模数据情况下表现很好并且非常节省内存，数据规模大时会有问题，并且插入和删除成本高。显然这时候QuickList该上场了。这时候让我们忘记3.0及之前的版本，开始进入新的结构吧。</p>
<p>首先看代码定义，<code>quicklist.h</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Node, quicklist, and Iterator are the only data structures used currently. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* quicklistNode is a 32 byte struct describing a ziplist for a quicklist.</span></span><br><span class="line"><span class="comment"> * We use bit fields keep the quicklistNode at 32 bytes.</span></span><br><span class="line"><span class="comment"> * count: 16 bits, max 65536 (max zl bytes is 65k, so max count actually &lt; 32k).</span></span><br><span class="line"><span class="comment"> * encoding: 2 bits, RAW=1, LZF=2.</span></span><br><span class="line"><span class="comment"> * container: 2 bits, NONE=1, ZIPLIST=2.</span></span><br><span class="line"><span class="comment"> * recompress: 1 bit, bool, true if node is temporarry decompressed for usage.</span></span><br><span class="line"><span class="comment"> * attempted_compress: 1 bit, boolean, used for verifying during testing.</span></span><br><span class="line"><span class="comment"> * extra: 10 bits, free for future use; pads out the remainder of 32 bits */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz;             <span class="comment">/* ziplist size in bytes */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count : <span class="number">16</span>;     <span class="comment">/* count of items in ziplist */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> encoding : <span class="number">2</span>;   <span class="comment">/* RAW==1 or LZF==2 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> container : <span class="number">2</span>;  <span class="comment">/* NONE==1 or ZIPLIST==2 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> recompress : <span class="number">1</span>; <span class="comment">/* was this node previous compressed? */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">/* node can't compress; too small */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> extra : <span class="number">10</span>; <span class="comment">/* more bits to steal for future usage */</span></span><br><span class="line">&#125; quicklistNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* quicklistLZF is a 4+N byte struct holding 'sz' followed by 'compressed'.</span></span><br><span class="line"><span class="comment"> * 'sz' is byte length of 'compressed' field.</span></span><br><span class="line"><span class="comment"> * 'compressed' is LZF data with total (compressed) length 'sz'</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> uncompressed length is stored in quicklistNode-&gt;sz.</span></span><br><span class="line"><span class="comment"> * When quicklistNode-&gt;zl is compressed, node-&gt;zl points to a quicklistLZF */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistLZF</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz; <span class="comment">/* LZF size in bytes*/</span></span><br><span class="line">    <span class="keyword">char</span> compressed[];</span><br><span class="line">&#125; quicklistLZF;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* quicklist is a 40 byte struct (on 64-bit systems) describing a quicklist.</span></span><br><span class="line"><span class="comment"> * 'count' is the number of total entries.</span></span><br><span class="line"><span class="comment"> * 'len' is the number of quicklist nodes.</span></span><br><span class="line"><span class="comment"> * 'compress' is: -1 if compression disabled, otherwise it's the number</span></span><br><span class="line"><span class="comment"> *                of quicklistNodes to leave uncompressed at ends of quicklist.</span></span><br><span class="line"><span class="comment"> * 'fill' is the user-requested (or default) fill factor. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    quicklistNode *head;</span><br><span class="line">    quicklistNode *tail;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> count;        <span class="comment">/* total count of all entries in all ziplists */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;          <span class="comment">/* number of quicklistNodes */</span></span><br><span class="line">    <span class="keyword">int</span> fill : <span class="number">16</span>;              <span class="comment">/* fill factor for individual nodes */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> compress : <span class="number">16</span>; <span class="comment">/* depth of end nodes not to compress;0=off */</span></span><br><span class="line">&#125; quicklist;</span><br></pre></td></tr></table></figure>
<p>乍一看貌似很复杂，但是整个结构却是非常的清晰。</p>
<p>首先是<code>quicklistNode</code>，这是<code>quicklist</code>的节点，可以看做对<code>ziplist</code>的高层封装。包含指向前后节点的指针，以及指向实际<code>ziplist</code>的指针zl，从定义上看，<code>quicklist</code>的节点上支持了压缩能力，并且多个字段通过位域方式申明内存节省空间。</p>
<p>而<code>quicklistLZF</code>用来存储压缩后的<code>ziplist</code>，占用空间4+N字节，其中N为压缩后的实际长度。</p>
<p>通过<code>quicklist</code>将<code>quicklistNode</code>连接起来，形成了完整的<code>quicklist</code>结构。由于<code>quicklist</code>同时包含了<code>ziplist</code>和<code>quicklist</code>的结构，因此每个<code>quicklistNode</code>的大小就非常重要：如果太大其就更接近ziplist，影响插入效率；如果太小就更接近<code>quicklist</code>，浪费空间。其通过<code>fill</code>字段来控制大小，正数表示单个节点允许的最大数量，最大为2^15，负数表示单个节点的内存空间大小，其中-1表示单个节点最多存储4kb，-2表示单个节点最多存储8kb，以此类推，-5表示单个节点最多保存64kb，在创建时默认的值为-2。这个字段的设置代码即判定是否还能继续插入数据的代码如下。compress表示压缩的深度，0表示不压缩，正数表示头尾多少个节点不压缩其余节点都压缩。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILL_MAX (1 &lt;&lt; 15)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistSetFill</span><span class="params">(quicklist *quicklist, <span class="keyword">int</span> fill)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fill &gt; FILL_MAX) &#123;</span><br><span class="line">        fill = FILL_MAX;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fill &lt; <span class="number">-5</span>) &#123;</span><br><span class="line">        fill = <span class="number">-5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    quicklist-&gt;fill = fill;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Maximum size in bytes of any multi-element ziplist.</span></span><br><span class="line"><span class="comment"> * Larger values will live in their own isolated ziplists. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_SAFETY_LIMIT 8192</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sizeMeetsSafetyLimit(sz) ((sz) &lt;= SIZE_SAFETY_LIMIT)</span></span><br><span class="line"></span><br><span class="line">REDIS_STATIC <span class="keyword">int</span> _quicklistNodeAllowInsert(<span class="keyword">const</span> quicklistNode *node,</span><br><span class="line">                                           <span class="keyword">const</span> <span class="keyword">int</span> fill, <span class="keyword">const</span> <span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!node))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ziplist_overhead;</span><br><span class="line">    <span class="comment">/* size of previous offset */</span></span><br><span class="line">    <span class="keyword">if</span> (sz &lt; <span class="number">254</span>)</span><br><span class="line">        ziplist_overhead = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ziplist_overhead = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* size of forward offset */</span></span><br><span class="line">    <span class="keyword">if</span> (sz &lt; <span class="number">64</span>)</span><br><span class="line">        ziplist_overhead += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (likely(sz &lt; <span class="number">16384</span>))</span><br><span class="line">        ziplist_overhead += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ziplist_overhead += <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* new_sz overestimates if 'sz' encodes to an integer type */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> new_sz = node-&gt;sz + sz + ziplist_overhead;</span><br><span class="line">    <span class="keyword">if</span> (likely(_quicklistNodeSizeMeetsOptimizationRequirement(new_sz, fill)))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!sizeMeetsSafetyLimit(new_sz))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">int</span>)node-&gt;count &lt; fill)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>quicklist使用<a href="https://en.wikipedia.org/wiki/Lossless_compression" target="_blank" rel="noopener">lzf</a>进行压缩，具体压缩算法略过，压缩节点的代码如下，开辟新的空间压缩ziplist数据，并且释放node-&gt;zl原有的内存，最后指向压缩后的数据并修改其他属性值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Minimum ziplist size in bytes for attempting compression. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_COMPRESS_BYTES 48</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Compress the ziplist in 'node' and update encoding details.</span></span><br><span class="line"><span class="comment"> * Returns 1 if ziplist compressed successfully.</span></span><br><span class="line"><span class="comment"> * Returns 0 if compression failed or if ziplist too small to compress. */</span></span><br><span class="line">REDIS_STATIC <span class="keyword">int</span> __quicklistCompressNode(quicklistNode *node) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> REDIS_TEST</span></span><br><span class="line">    node-&gt;attempted_compress = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't bother compressing small values */</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;sz &lt; MIN_COMPRESS_BYTES)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    quicklistLZF *lzf = zmalloc(<span class="keyword">sizeof</span>(*lzf) + node-&gt;sz);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Cancel if compression fails or doesn't compress small enough */</span></span><br><span class="line">    <span class="keyword">if</span> (((lzf-&gt;sz = lzf_compress(node-&gt;zl, node-&gt;sz, lzf-&gt;compressed,</span><br><span class="line">                                 node-&gt;sz)) == <span class="number">0</span>) ||</span><br><span class="line">        lzf-&gt;sz + MIN_COMPRESS_IMPROVE &gt;= node-&gt;sz) &#123;</span><br><span class="line">        <span class="comment">/* lzf_compress aborts/rejects compression if value not compressable. */</span></span><br><span class="line">        zfree(lzf);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lzf = zrealloc(lzf, <span class="keyword">sizeof</span>(*lzf) + lzf-&gt;sz);</span><br><span class="line">    zfree(node-&gt;zl);</span><br><span class="line">    node-&gt;zl = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)lzf;</span><br><span class="line">    node-&gt;encoding = QUICKLIST_NODE_ENCODING_LZF;</span><br><span class="line">    node-&gt;recompress = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，解压的代码如下，开辟新的空间存放解压后的数据，同时释放压缩数据的空间，node-&gt;zl指向新的解压后的数据，最后修改其他属性值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Uncompress the ziplist in 'node' and update encoding details.</span></span><br><span class="line"><span class="comment"> * Returns 1 on successful decode, 0 on failure to decode. */</span></span><br><span class="line">REDIS_STATIC <span class="keyword">int</span> __quicklistDecompressNode(quicklistNode *node) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> REDIS_TEST</span></span><br><span class="line">    node-&gt;attempted_compress = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *decompressed = zmalloc(node-&gt;sz);</span><br><span class="line">    quicklistLZF *lzf = (quicklistLZF *)node-&gt;zl;</span><br><span class="line">    <span class="keyword">if</span> (lzf_decompress(lzf-&gt;compressed, lzf-&gt;sz, decompressed, node-&gt;sz) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Someone requested decompress, but we can't decompress.  Not good. */</span></span><br><span class="line">        zfree(decompressed);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    zfree(lzf);</span><br><span class="line">    node-&gt;zl = decompressed;</span><br><span class="line">    node-&gt;encoding = QUICKLIST_NODE_ENCODING_RAW;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在头尾插入节点如下，如果单个ziplist满足上面说到的大小、数量限制，则使用ziplist的push函数直接插入，否则新建一个节点用来插入即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Add new entry to head node of quicklist.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns 0 if used existing head.</span></span><br><span class="line"><span class="comment"> * Returns 1 if new head created. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPushHead</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, <span class="keyword">size_t</span> sz)</span> </span>&#123;</span><br><span class="line">    quicklistNode *orig_head = quicklist-&gt;head;</span><br><span class="line">    <span class="keyword">if</span> (likely(</span><br><span class="line">            _quicklistNodeAllowInsert(quicklist-&gt;head, quicklist-&gt;fill, sz))) &#123;</span><br><span class="line">        quicklist-&gt;head-&gt;zl =</span><br><span class="line">            ziplistPush(quicklist-&gt;head-&gt;zl, value, sz, ZIPLIST_HEAD);</span><br><span class="line">        quicklistNodeUpdateSz(quicklist-&gt;head);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        quicklistNode *node = quicklistCreateNode();</span><br><span class="line">        node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);</span><br><span class="line"></span><br><span class="line">        quicklistNodeUpdateSz(node);</span><br><span class="line">        _quicklistInsertNodeBefore(quicklist, quicklist-&gt;head, node);</span><br><span class="line">    &#125;</span><br><span class="line">    quicklist-&gt;count++;</span><br><span class="line">    quicklist-&gt;head-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> (orig_head != quicklist-&gt;head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add new entry to tail node of quicklist.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns 0 if used existing tail.</span></span><br><span class="line"><span class="comment"> * Returns 1 if new tail created. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPushTail</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, <span class="keyword">size_t</span> sz)</span> </span>&#123;</span><br><span class="line">    quicklistNode *orig_tail = quicklist-&gt;tail;</span><br><span class="line">    <span class="keyword">if</span> (likely(</span><br><span class="line">            _quicklistNodeAllowInsert(quicklist-&gt;tail, quicklist-&gt;fill, sz))) &#123;</span><br><span class="line">        quicklist-&gt;tail-&gt;zl =</span><br><span class="line">            ziplistPush(quicklist-&gt;tail-&gt;zl, value, sz, ZIPLIST_TAIL);</span><br><span class="line">        quicklistNodeUpdateSz(quicklist-&gt;tail);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        quicklistNode *node = quicklistCreateNode();</span><br><span class="line">        node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_TAIL);</span><br><span class="line"></span><br><span class="line">        quicklistNodeUpdateSz(node);</span><br><span class="line">        _quicklistInsertNodeAfter(quicklist, quicklist-&gt;tail, node);</span><br><span class="line">    &#125;</span><br><span class="line">    quicklist-&gt;count++;</span><br><span class="line">    quicklist-&gt;tail-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> (orig_tail != quicklist-&gt;tail);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，quicklist还提供了merge、旋转、指定节点前后插入等功能，均在<code>quicklist.[h|c]</code>中，其主要在linkedlist的基础上，对于每个节点融合ziplist的特征，并且对于中间节点还提供了lzf压缩的能力，综合了linkedlist和ziplist的有点，同时具有节省内存、插入删除数据高效的特点。整个quicklist的简单示意图可如下图。</p>
<p><img src="/images/from-ziplist-linkedlist-to-quicklist/15774679538508.jpg" title="quicklist示意图" alt="quicklist示意图"></p>
<h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p>测试平台：macOS Catalina 10.15.2，Intel Core i7 2.2GHz，16GB 1600MHz DDR3</p>
<p>因为系统上已有通过homebrew安装64位的5.0.7版本Redis，因此先看这个版本。因为打算对比quicklist、ziplist以及linkedlist，所以选择list结构进行测试。为了测试存储空间、插入删除性能，在不同测试中均使用<code>redis-benchmark</code>执行相同的测试。</p>
<p>对于ziplist以及linkedlist，使用本地编译的64位3.0.6版本。</p>
<h3 id="quicklist的性能"><a href="#quicklist的性能" class="headerlink" title="quicklist的性能"></a>quicklist的性能</h3><p>首先向quicklist插入1000条定长数据：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ redis-benchmark -t lpush -n 1000</span><br><span class="line">====== LPUSH ======</span><br><span class="line">  1000 requests completed <span class="keyword">in</span> 0.02 seconds</span><br><span class="line">  50 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">99.90% &lt;= 1 milliseconds</span><br><span class="line">100.00% &lt;= 1 milliseconds</span><br><span class="line">55555.56 requests per second</span><br><span class="line"></span><br><span class="line">$ redis-cli</span><br><span class="line">127.0.0.1:6379&gt; memory usage mylist</span><br><span class="line">(<span class="built_in">integer</span>) 5131</span><br></pre></td></tr></table></figure></p>
<p>实际使用5131字节，相当于每个元素使用约5.1字节，空间利用率约58.5%（实际插入的是”xxx“，三个字节长）。</p>
<p>再向quicklist的list中插入1000000个定长数据</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">$ redis-benchmark -t lpush -n 1000000</span><br><span class="line"></span><br><span class="line">====== LPUSH ======</span><br><span class="line">  1000000 requests completed <span class="keyword">in</span> 12.36 seconds</span><br><span class="line">  50 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">99.44% &lt;= 1 milliseconds</span><br><span class="line">99.85% &lt;= 2 milliseconds</span><br><span class="line">99.91% &lt;= 3 milliseconds</span><br><span class="line">99.93% &lt;= 4 milliseconds</span><br><span class="line">99.94% &lt;= 5 milliseconds</span><br><span class="line">99.95% &lt;= 6 milliseconds</span><br><span class="line">99.96% &lt;= 7 milliseconds</span><br><span class="line">99.97% &lt;= 8 milliseconds</span><br><span class="line">99.99% &lt;= 9 milliseconds</span><br><span class="line">99.99% &lt;= 10 milliseconds</span><br><span class="line">100.00% &lt;= 11 milliseconds</span><br><span class="line">100.00% &lt;= 17 milliseconds</span><br><span class="line">100.00% &lt;= 18 milliseconds</span><br><span class="line">100.00% &lt;= 18 milliseconds</span><br><span class="line">80893.05 requests per second</span><br><span class="line"></span><br><span class="line">$ redis-cli</span><br><span class="line">127.0.0.1:6379&gt; DEBUG OBJECT mylist</span><br><span class="line">Value at:0x7fd2ca51c2e0 refcount:1 encoding:quicklist serializedlength:72148 lru:462431 lru_seconds_idle:57 ql_nodes:612 ql_avg_node:1633.99 ql_ziplist_max:-2 ql_compressed:0 ql_uncompressed_size:5006732</span><br><span class="line"></span><br><span class="line">$ redis-benchmark -t lpop -n 1000000</span><br><span class="line">====== LPOP ======</span><br><span class="line">  1000000 requests completed <span class="keyword">in</span> 13.80 seconds</span><br><span class="line">  50 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">98.47% &lt;= 1 milliseconds</span><br><span class="line">99.65% &lt;= 2 milliseconds</span><br><span class="line">99.80% &lt;= 3 milliseconds</span><br><span class="line">99.87% &lt;= 4 milliseconds</span><br><span class="line">99.89% &lt;= 5 milliseconds</span><br><span class="line">99.91% &lt;= 6 milliseconds</span><br><span class="line">99.92% &lt;= 7 milliseconds</span><br><span class="line">99.94% &lt;= 8 milliseconds</span><br><span class="line">99.95% &lt;= 9 milliseconds</span><br><span class="line">99.97% &lt;= 10 milliseconds</span><br><span class="line">99.97% &lt;= 11 milliseconds</span><br><span class="line">99.98% &lt;= 12 milliseconds</span><br><span class="line">99.98% &lt;= 13 milliseconds</span><br><span class="line">99.98% &lt;= 14 milliseconds</span><br><span class="line">99.99% &lt;= 15 milliseconds</span><br><span class="line">99.99% &lt;= 17 milliseconds</span><br><span class="line">99.99% &lt;= 21 milliseconds</span><br><span class="line">99.99% &lt;= 22 milliseconds</span><br><span class="line">99.99% &lt;= 26 milliseconds</span><br><span class="line">100.00% &lt;= 27 milliseconds</span><br><span class="line">100.00% &lt;= 29 milliseconds</span><br><span class="line">100.00% &lt;= 30 milliseconds</span><br><span class="line">100.00% &lt;= 30 milliseconds</span><br><span class="line">72442.77 requests per second</span><br></pre></td></tr></table></figure>
<p>可以看出，其插入速度基本都能保持在1ms以内，并且在未压缩情况下（value空间小于<code>MIN_COMPRESS_BYTES</code>即48字节，不执行压缩），共有612个quicklist节点，总共占用5006732字节内存，即每个值仅占用约5字节，而实际插入的值<code>&quot;xxx&quot;</code>本身是3字节长，约60%的空间利用率。弹出速度也大量保持在1ms以内。</p>
<p>接着尝试插入更长的数据，先不开启quicklist的，再看看插入和弹出性能以及内存占用情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">$ redis-benchmark -n 1000000 lpush mylist <span class="string">"mylist str len: 463. Redis is not a plain key-value store, it is actually a data structures server, supporting different kinds of values. What this means is that, while in traditional key-value stores you associated string keys to string values, in Redis the value is not limited to a simple string, but can also hold more complex data structures. The following is the list of all the data structures supported by Redis, which will be covered separately in this tutorial"</span></span><br><span class="line">====== lpush mylist str len: 463. Redis is not a plain key-value store, it is actually a data structures server, supporting different kinds of values. What this means is that, <span class="keyword">while</span> <span class="keyword">in</span> traditional key-value stores you associated string keys to string values, <span class="keyword">in</span> Redis the value is not limited to a simple string, but can also hold more complex data structures. The following is the list of all the data structures supported by Redis, <span class="built_in">which</span> will be covered separately <span class="keyword">in</span> this tutorial ======</span><br><span class="line">  1000000 requests completed <span class="keyword">in</span> 14.27 seconds</span><br><span class="line">  50 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">97.91% &lt;= 1 milliseconds</span><br><span class="line">99.61% &lt;= 2 milliseconds</span><br><span class="line">99.83% &lt;= 3 milliseconds</span><br><span class="line">99.88% &lt;= 4 milliseconds</span><br><span class="line">99.90% &lt;= 5 milliseconds</span><br><span class="line">99.92% &lt;= 6 milliseconds</span><br><span class="line">99.93% &lt;= 7 milliseconds</span><br><span class="line">99.94% &lt;= 8 milliseconds</span><br><span class="line">99.95% &lt;= 9 milliseconds</span><br><span class="line">99.95% &lt;= 10 milliseconds</span><br><span class="line">99.96% &lt;= 11 milliseconds</span><br><span class="line">99.98% &lt;= 12 milliseconds</span><br><span class="line">99.98% &lt;= 13 milliseconds</span><br><span class="line">99.99% &lt;= 16 milliseconds</span><br><span class="line">99.99% &lt;= 17 milliseconds</span><br><span class="line">99.99% &lt;= 18 milliseconds</span><br><span class="line">100.00% &lt;= 19 milliseconds</span><br><span class="line">100.00% &lt;= 28 milliseconds</span><br><span class="line">100.00% &lt;= 28 milliseconds</span><br><span class="line">70081.99 requests per second</span><br><span class="line"></span><br><span class="line">$ redis-cli</span><br><span class="line">127.0.0.1:6379&gt; DEBUG OBJECT mylist</span><br><span class="line">Value at:0x7fd2cfa025d0 refcount:1 encoding:quicklist serializedlength:29294298 lru:465570 lru_seconds_idle:6 ql_nodes:58824 ql_avg_node:17.00 ql_ziplist_max:-2 ql_compressed:0 ql_uncompressed_size:470411768</span><br><span class="line">127.0.0.1:6379&gt; memory usage mylist</span><br><span class="line">(<span class="built_in">integer</span>) 428062336</span><br><span class="line"></span><br><span class="line">$ redis-benchmark -t lpop -n 1000000</span><br><span class="line">====== LPOP ======</span><br><span class="line">  1000000 requests completed <span class="keyword">in</span> 13.50 seconds</span><br><span class="line">  50 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">98.24% &lt;= 1 milliseconds</span><br><span class="line">99.58% &lt;= 2 milliseconds</span><br><span class="line">99.77% &lt;= 3 milliseconds</span><br><span class="line">99.85% &lt;= 4 milliseconds</span><br><span class="line">99.88% &lt;= 5 milliseconds</span><br><span class="line">99.91% &lt;= 6 milliseconds</span><br><span class="line">99.94% &lt;= 7 milliseconds</span><br><span class="line">99.95% &lt;= 8 milliseconds</span><br><span class="line">99.96% &lt;= 9 milliseconds</span><br><span class="line">99.96% &lt;= 10 milliseconds</span><br><span class="line">99.97% &lt;= 11 milliseconds</span><br><span class="line">99.98% &lt;= 12 milliseconds</span><br><span class="line">99.98% &lt;= 13 milliseconds</span><br><span class="line">99.99% &lt;= 14 milliseconds</span><br><span class="line">99.99% &lt;= 15 milliseconds</span><br><span class="line">99.99% &lt;= 16 milliseconds</span><br><span class="line">100.00% &lt;= 17 milliseconds</span><br><span class="line">100.00% &lt;= 18 milliseconds</span><br><span class="line">74057.62 requests per second</span><br></pre></td></tr></table></figure>
<p>可以看出，随着字符串的变长，实际的插入、弹出时间相差不大，每个元素占用空间<code>470411768/1000000≈470</code>字节，约98.5%的空间利用率。实际内存空间使用<code>428062336</code>字节，约408M。</p>
<p>如果开启压缩，设置<code>list-compress-depth</code>为1，再进行相同的测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">$ redis-benchmark -n 1000000 lpush mylist <span class="string">"mylist str len: 463. Redis is not a plain key-value store, it is actually a data structures server, supporting different kinds of values. What this means is that, while in traditional key-value stores you associated string keys to string values, in Redis the value is not limited to a simple string, but can also hold more complex data structures. The following is the list of all the data structures supported by Redis, which will be covered separately in this tutorial"</span></span><br><span class="line">====== lpush mylist str len: 463. Redis is not a plain key-value store, it is actually a data structures server, supporting different kinds of values. What this means is that, <span class="keyword">while</span> <span class="keyword">in</span> traditional key-value stores you associated string keys to string values, <span class="keyword">in</span> Redis the value is not limited to a simple string, but can also hold more complex data structures. The following is the list of all the data structures supported by Redis, <span class="built_in">which</span> will be covered separately <span class="keyword">in</span> this tutorial ======</span><br><span class="line">  1000000 requests completed <span class="keyword">in</span> 13.99 seconds</span><br><span class="line">  50 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">98.09% &lt;= 1 milliseconds</span><br><span class="line">99.72% &lt;= 2 milliseconds</span><br><span class="line">99.86% &lt;= 3 milliseconds</span><br><span class="line">99.90% &lt;= 4 milliseconds</span><br><span class="line">99.92% &lt;= 5 milliseconds</span><br><span class="line">99.94% &lt;= 6 milliseconds</span><br><span class="line">99.94% &lt;= 7 milliseconds</span><br><span class="line">99.95% &lt;= 8 milliseconds</span><br><span class="line">99.96% &lt;= 9 milliseconds</span><br><span class="line">99.96% &lt;= 10 milliseconds</span><br><span class="line">99.97% &lt;= 11 milliseconds</span><br><span class="line">99.97% &lt;= 12 milliseconds</span><br><span class="line">99.98% &lt;= 13 milliseconds</span><br><span class="line">99.99% &lt;= 14 milliseconds</span><br><span class="line">99.99% &lt;= 15 milliseconds</span><br><span class="line">100.00% &lt;= 24 milliseconds</span><br><span class="line">100.00% &lt;= 25 milliseconds</span><br><span class="line">100.00% &lt;= 27 milliseconds</span><br><span class="line">71489.85 requests per second</span><br><span class="line"></span><br><span class="line">$ redis-cli</span><br><span class="line">127.0.0.1:6379&gt; DEBUG OBJECT mylist</span><br><span class="line">Value at:0x7fd2ca4355f0 refcount:1 encoding:quicklist serializedlength:29294298 lru:465449 lru_seconds_idle:6 ql_nodes:58824 ql_avg_node:17.00 ql_ziplist_max:-2 ql_compressed:1 ql_uncompressed_size:470411768</span><br><span class="line">127.0.0.1:6379&gt; memory usage mylist</span><br><span class="line">(<span class="built_in">integer</span>) 74930099</span><br><span class="line"></span><br><span class="line">$ redis-benchmark -t lpop -n 1000000</span><br><span class="line">====== LPOP ======</span><br><span class="line">  1000000 requests completed <span class="keyword">in</span> 13.63 seconds</span><br><span class="line">  50 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">98.42% &lt;= 1 milliseconds</span><br><span class="line">99.69% &lt;= 2 milliseconds</span><br><span class="line">99.84% &lt;= 3 milliseconds</span><br><span class="line">99.88% &lt;= 4 milliseconds</span><br><span class="line">99.90% &lt;= 5 milliseconds</span><br><span class="line">99.91% &lt;= 6 milliseconds</span><br><span class="line">99.93% &lt;= 7 milliseconds</span><br><span class="line">99.95% &lt;= 8 milliseconds</span><br><span class="line">99.98% &lt;= 9 milliseconds</span><br><span class="line">99.98% &lt;= 10 milliseconds</span><br><span class="line">99.99% &lt;= 11 milliseconds</span><br><span class="line">99.99% &lt;= 12 milliseconds</span><br><span class="line">99.99% &lt;= 14 milliseconds</span><br><span class="line">100.00% &lt;= 31 milliseconds</span><br><span class="line">100.00% &lt;= 32 milliseconds</span><br><span class="line">100.00% &lt;= 32 milliseconds</span><br><span class="line">73351.42 requests per second</span><br></pre></td></tr></table></figure>
<p>可以看出，在进行lzf压缩后，插入、弹出元素的时间相差无几，但是实际的空间占用降到了<code>74930099</code>，即约71M，空间节省极大。</p>
<h3 id="linkedlist的性能"><a href="#linkedlist的性能" class="headerlink" title="linkedlist的性能"></a>linkedlist的性能</h3><p>在redis中，通过两处配置定义list底层使用的数据结构。<code>list-max-ziplist-entries</code>表示ziplist元素最大值，list-max-ziplist-value表示单个节点的最大长度。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Similarly to hashes, small lists are also encoded in a special way in order</span></span><br><span class="line"><span class="comment"># to save a lot of space. The special representation is only used when</span></span><br><span class="line"><span class="comment"># you are under the following limits:</span></span><br><span class="line">list-max-ziplist-entries 512</span><br><span class="line">list-max-ziplist-value 64</span><br></pre></td></tr></table></figure></p>
<p>如果元素的值的长度或者数量超过了配置值的任何一个，则ziplist会自动转变为linkedlist并且不会退化回ziplist，转换的代码如下，可以看到只允许转为<code>REDIS_ENCODING_LINKEDLIST</code>的单向转换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listTypeConvert</span><span class="params">(robj *subject, <span class="keyword">int</span> enc)</span> </span>&#123;</span><br><span class="line">    listTypeIterator *li;</span><br><span class="line">    listTypeEntry entry;</span><br><span class="line">    redisAssertWithInfo(<span class="literal">NULL</span>,subject,subject-&gt;type == REDIS_LIST);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enc == REDIS_ENCODING_LINKEDLIST) &#123;</span><br><span class="line">        <span class="built_in">list</span> *l = listCreate();</span><br><span class="line">        listSetFreeMethod(l,decrRefCountVoid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* listTypeGet returns a robj with incremented refcount */</span></span><br><span class="line">        li = listTypeInitIterator(subject,<span class="number">0</span>,REDIS_TAIL);</span><br><span class="line">        <span class="keyword">while</span> (listTypeNext(li,&amp;entry)) listAddNodeTail(l,listTypeGet(&amp;entry));</span><br><span class="line">        listTypeReleaseIterator(li);</span><br><span class="line"></span><br><span class="line">        subject-&gt;encoding = REDIS_ENCODING_LINKEDLIST;</span><br><span class="line">        zfree(subject-&gt;ptr);</span><br><span class="line">        subject-&gt;ptr = l;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">"Unsupported list conversion"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此启动<code>redis-server</code>时显式的指定<code>list-max-ziplist-entries</code>为0即可使用linkedlist进行测试。</p>
<p>插入100条数据：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ redis-benchmark -t lpush -n 100</span><br><span class="line">====== LPUSH ======</span><br><span class="line">  1000 requests completed <span class="keyword">in</span> 0.01 seconds</span><br><span class="line">  50 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">100.00% &lt;= 0 milliseconds</span><br><span class="line">66666.67 requests per second</span><br></pre></td></tr></table></figure>
<p>通过redisinsight分析其实际使用内存44kb，即单个元素占用约45字节，空间利用率约6.7%。</p>
<p>同样，插入1000000个定长数据：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">$ redis-benchmark -t lpush -n 1000000</span><br><span class="line"></span><br><span class="line">====== LPUSH ======</span><br><span class="line">  1000000 requests completed <span class="keyword">in</span> 13.08 seconds</span><br><span class="line">  50 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">98.75% &lt;= 1 milliseconds</span><br><span class="line">99.72% &lt;= 2 milliseconds</span><br><span class="line">99.83% &lt;= 3 milliseconds</span><br><span class="line">99.87% &lt;= 4 milliseconds</span><br><span class="line">99.90% &lt;= 5 milliseconds</span><br><span class="line">99.92% &lt;= 6 milliseconds</span><br><span class="line">99.94% &lt;= 7 milliseconds</span><br><span class="line">99.95% &lt;= 8 milliseconds</span><br><span class="line">99.96% &lt;= 9 milliseconds</span><br><span class="line">99.96% &lt;= 10 milliseconds</span><br><span class="line">99.97% &lt;= 11 milliseconds</span><br><span class="line">99.97% &lt;= 12 milliseconds</span><br><span class="line">99.99% &lt;= 13 milliseconds</span><br><span class="line">100.00% &lt;= 28 milliseconds</span><br><span class="line">100.00% &lt;= 29 milliseconds</span><br><span class="line">100.00% &lt;= 30 milliseconds</span><br><span class="line">76440.91 requests per second</span><br><span class="line"></span><br><span class="line">$ redis-cli</span><br><span class="line">127.0.0.1:6379&gt; DEBUG OBJECT mylist</span><br><span class="line">Value at:0x7fc41b433aa0 refcount:1 encoding:linkedlist serializedlength:4000005 lru:472156 lru_seconds_idle:24</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ redis-benchmark -t lpop -n 1000000</span><br><span class="line">====== LPOP ======</span><br><span class="line">  1000000 requests completed <span class="keyword">in</span> 13.80 seconds</span><br><span class="line">  50 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">98.47% &lt;= 1 milliseconds</span><br><span class="line">99.65% &lt;= 2 milliseconds</span><br><span class="line">99.80% &lt;= 3 milliseconds</span><br><span class="line">99.87% &lt;= 4 milliseconds</span><br><span class="line">99.89% &lt;= 5 milliseconds</span><br><span class="line">99.91% &lt;= 6 milliseconds</span><br><span class="line">99.92% &lt;= 7 milliseconds</span><br><span class="line">99.94% &lt;= 8 milliseconds</span><br><span class="line">99.95% &lt;= 9 milliseconds</span><br><span class="line">99.97% &lt;= 10 milliseconds</span><br><span class="line">99.97% &lt;= 11 milliseconds</span><br><span class="line">99.98% &lt;= 12 milliseconds</span><br><span class="line">99.98% &lt;= 13 milliseconds</span><br><span class="line">99.98% &lt;= 14 milliseconds</span><br><span class="line">99.99% &lt;= 15 milliseconds</span><br><span class="line">99.99% &lt;= 17 milliseconds</span><br><span class="line">99.99% &lt;= 21 milliseconds</span><br><span class="line">99.99% &lt;= 22 milliseconds</span><br><span class="line">99.99% &lt;= 26 milliseconds</span><br><span class="line">100.00% &lt;= 27 milliseconds</span><br><span class="line">100.00% &lt;= 29 milliseconds</span><br><span class="line">100.00% &lt;= 30 milliseconds</span><br><span class="line">100.00% &lt;= 30 milliseconds</span><br><span class="line">72442.77 requests per second</span><br></pre></td></tr></table></figure>
<p>其实际使用内存43M，即单个节点使用约45字节的空间，空间利用率约6.7%。但是在插入与弹出的时间消耗上，和quicklist相差不大。</p>
<p>再看看插入长字符串的情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">$ redis-benchmark -n 1000000 lpush mylist <span class="string">"mylist str len: 463. Redis is not a plain key-value store, it is actually a data structures server, supporting different kinds of values. What this means is that, while in traditional key-value stores you associated string keys to string values, in Redis the value is not limited to a simple string, but can also hold more complex data structures. The following is the list of all the data structures supported by Redis, which will be covered separately in this tutorial"</span></span><br><span class="line">====== lpush mylist mylist str len: 463. Redis is not a plain key-value store, it is actually a data structures server, supporting different kinds of values. What this means is that, <span class="keyword">while</span> <span class="keyword">in</span> traditional key-value stores you associated string keys to string values, <span class="keyword">in</span> Redis the value is not limited to a simple string, but can also hold more complex data structures. The following is the list of all the data structures supported by Redis, <span class="built_in">which</span> will be covered separately <span class="keyword">in</span> this tutorial ======</span><br><span class="line">  1000000 requests completed <span class="keyword">in</span> 14.24 seconds</span><br><span class="line">  50 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">97.33% &lt;= 1 milliseconds</span><br><span class="line">99.64% &lt;= 2 milliseconds</span><br><span class="line">99.83% &lt;= 3 milliseconds</span><br><span class="line">99.87% &lt;= 4 milliseconds</span><br><span class="line">99.91% &lt;= 5 milliseconds</span><br><span class="line">99.93% &lt;= 6 milliseconds</span><br><span class="line">99.94% &lt;= 7 milliseconds</span><br><span class="line">99.94% &lt;= 8 milliseconds</span><br><span class="line">99.97% &lt;= 9 milliseconds</span><br><span class="line">99.98% &lt;= 10 milliseconds</span><br><span class="line">99.98% &lt;= 11 milliseconds</span><br><span class="line">99.99% &lt;= 12 milliseconds</span><br><span class="line">99.99% &lt;= 13 milliseconds</span><br><span class="line">100.00% &lt;= 15 milliseconds</span><br><span class="line">100.00% &lt;= 16 milliseconds</span><br><span class="line">100.00% &lt;= 17 milliseconds</span><br><span class="line">100.00% &lt;= 18 milliseconds</span><br><span class="line">100.00% &lt;= 25 milliseconds</span><br><span class="line">100.00% &lt;= 25 milliseconds</span><br><span class="line">70239.52 requests per second</span><br><span class="line"></span><br><span class="line">$ redis-cli</span><br><span class="line">127.0.0.1:6379&gt; DEBUG OBJECT mylist</span><br><span class="line">Value at:0x7fc616f03f80 refcount:1 encoding:linkedlist serializedlength:371000005 lru:473445 lru_seconds_idle:26</span><br><span class="line"></span><br><span class="line">$ redis-benchmark -t lpop -n 1000000</span><br><span class="line">====== LPOP ======</span><br><span class="line">  1000000 requests completed <span class="keyword">in</span> 12.65 seconds</span><br><span class="line">  50 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">98.67% &lt;= 1 milliseconds</span><br><span class="line">99.78% &lt;= 2 milliseconds</span><br><span class="line">99.89% &lt;= 3 milliseconds</span><br><span class="line">99.90% &lt;= 4 milliseconds</span><br><span class="line">99.92% &lt;= 5 milliseconds</span><br><span class="line">99.95% &lt;= 6 milliseconds</span><br><span class="line">99.95% &lt;= 7 milliseconds</span><br><span class="line">99.97% &lt;= 8 milliseconds</span><br><span class="line">99.98% &lt;= 9 milliseconds</span><br><span class="line">99.98% &lt;= 10 milliseconds</span><br><span class="line">99.98% &lt;= 11 milliseconds</span><br><span class="line">99.99% &lt;= 12 milliseconds</span><br><span class="line">100.00% &lt;= 13 milliseconds</span><br><span class="line">100.00% &lt;= 13 milliseconds</span><br><span class="line">79026.39 requests per second</span><br></pre></td></tr></table></figure>
<p>通过redisinsight分析其实际使用内存488M，即单个节点使用约512字节的空间，空间利用率约90.4%。但是在插入与弹出的时间消耗上，和quicklist以及短字符串插入都相差不大。</p>
<h3 id="ziplist的性能"><a href="#ziplist的性能" class="headerlink" title="ziplist的性能"></a>ziplist的性能</h3><p>最后再看看ziplist的表现。设置<code>list-max-ziplist-entries</code>与<code>list-max-ziplist-value</code>为较大的值来启动redis-server，保证使用ziplist编码来实现list。我们先插入比较少的数据：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ redis-benchmark -t lpush -n 100</span><br><span class="line">====== LPUSH ======</span><br><span class="line">  100 requests completed <span class="keyword">in</span> 0.00 seconds</span><br><span class="line">  50 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">100.00% &lt;= 0 milliseconds</span><br><span class="line">50000.00 requests per second</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ redis-cli</span><br><span class="line">127.0.0.1:6379&gt; DEBUG OBJECT mylist</span><br><span class="line">Value at:0x7f82e9100890 refcount:1 encoding:ziplist serializedlength:30 lru:473656 lru_seconds_idle:36</span><br><span class="line"></span><br><span class="line">$ redis-benchmark -t lpop -n 100</span><br><span class="line">====== LPOP ======</span><br><span class="line">  100 requests completed <span class="keyword">in</span> 0.00 seconds</span><br><span class="line">  50 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">100.00% &lt;= 0 milliseconds</span><br><span class="line">33333.33 requests per second</span><br></pre></td></tr></table></figure>
<p>分析内存占用，100个元素总共占用约553字节空间，平均一个元素约5.5字节，空间利用率约54.5%。</p>
<p>因为ziplist插入数据量过大可能非常的慢，甚至每秒的请求数量能到个位数，因此来看看插入100000个元素的情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">$ redis-benchmark -t lpush -n 100000</span><br><span class="line">====== LPUSH ======</span><br><span class="line">  100000 requests completed <span class="keyword">in</span> 39.20 seconds</span><br><span class="line">  50 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">37.85% &lt;= 1 milliseconds</span><br><span class="line">64.63% &lt;= 2 milliseconds</span><br><span class="line">65.22% &lt;= 3 milliseconds</span><br><span class="line">65.37% &lt;= 4 milliseconds</span><br><span class="line">65.43% &lt;= 5 milliseconds</span><br><span class="line">65.43% &lt;= 6 milliseconds</span><br><span class="line">65.45% &lt;= 7 milliseconds</span><br><span class="line">65.47% &lt;= 9 milliseconds</span><br><span class="line">65.47% &lt;= 11 milliseconds</span><br><span class="line">65.47% &lt;= 12 milliseconds</span><br><span class="line">65.47% &lt;= 13 milliseconds</span><br><span class="line">65.48% &lt;= 14 milliseconds</span><br><span class="line">65.53% &lt;= 15 milliseconds</span><br><span class="line">65.53% &lt;= 16 milliseconds</span><br><span class="line">65.53% &lt;= 17 milliseconds</span><br><span class="line">65.53% &lt;= 18 milliseconds</span><br><span class="line">65.53% &lt;= 19 milliseconds</span><br><span class="line">65.54% &lt;= 20 milliseconds</span><br><span class="line">65.54% &lt;= 23 milliseconds</span><br><span class="line">65.54% &lt;= 26 milliseconds</span><br><span class="line">65.54% &lt;= 27 milliseconds</span><br><span class="line">65.54% &lt;= 28 milliseconds</span><br><span class="line">65.54% &lt;= 29 milliseconds</span><br><span class="line">65.55% &lt;= 30 milliseconds</span><br><span class="line">65.55% &lt;= 32 milliseconds</span><br><span class="line">65.55% &lt;= 34 milliseconds</span><br><span class="line">65.55% &lt;= 35 milliseconds</span><br><span class="line">65.56% &lt;= 36 milliseconds</span><br><span class="line">65.56% &lt;= 38 milliseconds</span><br><span class="line">65.57% &lt;= 39 milliseconds</span><br><span class="line">65.57% &lt;= 40 milliseconds</span><br><span class="line">65.57% &lt;= 41 milliseconds</span><br><span class="line">65.58% &lt;= 42 milliseconds</span><br><span class="line">65.97% &lt;= 43 milliseconds</span><br><span class="line">67.04% &lt;= 44 milliseconds</span><br><span class="line">68.92% &lt;= 45 milliseconds</span><br><span class="line">70.23% &lt;= 46 milliseconds</span><br><span class="line">71.32% &lt;= 47 milliseconds</span><br><span class="line">72.07% &lt;= 48 milliseconds</span><br><span class="line">72.97% &lt;= 49 milliseconds</span><br><span class="line">74.51% &lt;= 50 milliseconds</span><br><span class="line">76.12% &lt;= 51 milliseconds</span><br><span class="line">78.02% &lt;= 52 milliseconds</span><br><span class="line">80.05% &lt;= 53 milliseconds</span><br><span class="line">81.86% &lt;= 54 milliseconds</span><br><span class="line">83.42% &lt;= 55 milliseconds</span><br><span class="line">84.66% &lt;= 56 milliseconds</span><br><span class="line">86.14% &lt;= 57 milliseconds</span><br><span class="line">87.74% &lt;= 58 milliseconds</span><br><span class="line">89.33% &lt;= 59 milliseconds</span><br><span class="line">90.45% &lt;= 60 milliseconds</span><br><span class="line">91.75% &lt;= 61 milliseconds</span><br><span class="line">93.67% &lt;= 62 milliseconds</span><br><span class="line">95.49% &lt;= 63 milliseconds</span><br><span class="line">96.69% &lt;= 64 milliseconds</span><br><span class="line">97.84% &lt;= 65 milliseconds</span><br><span class="line">98.68% &lt;= 66 milliseconds</span><br><span class="line">99.03% &lt;= 67 milliseconds</span><br><span class="line">99.20% &lt;= 68 milliseconds</span><br><span class="line">99.43% &lt;= 69 milliseconds</span><br><span class="line">99.54% &lt;= 70 milliseconds</span><br><span class="line">99.66% &lt;= 71 milliseconds</span><br><span class="line">99.78% &lt;= 72 milliseconds</span><br><span class="line">99.84% &lt;= 73 milliseconds</span><br><span class="line">99.87% &lt;= 74 milliseconds</span><br><span class="line">99.90% &lt;= 75 milliseconds</span><br><span class="line">99.92% &lt;= 76 milliseconds</span><br><span class="line">99.93% &lt;= 77 milliseconds</span><br><span class="line">99.96% &lt;= 78 milliseconds</span><br><span class="line">99.97% &lt;= 79 milliseconds</span><br><span class="line">99.99% &lt;= 80 milliseconds</span><br><span class="line">100.00% &lt;= 81 milliseconds</span><br><span class="line">2551.15 requests per second</span><br><span class="line"></span><br><span class="line">$ redis-cli</span><br><span class="line">127.0.0.1:6379&gt; DEBUG OBJECT mylist</span><br><span class="line">Value at:0x7f82e9100890 refcount:1 encoding:ziplist serializedlength:30 lru:473656 lru_seconds_idle:36</span><br><span class="line"></span><br><span class="line">$ redis-benchmark -t lpop -n 100000</span><br><span class="line">====== LPOP ======</span><br><span class="line">  100000 requests completed <span class="keyword">in</span> 21.04 seconds</span><br><span class="line">  50 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">42.08% &lt;= 1 milliseconds</span><br><span class="line">63.70% &lt;= 2 milliseconds</span><br><span class="line">65.00% &lt;= 3 milliseconds</span><br><span class="line">65.26% &lt;= 4 milliseconds</span><br><span class="line">65.36% &lt;= 5 milliseconds</span><br><span class="line">65.37% &lt;= 6 milliseconds</span><br><span class="line">65.38% &lt;= 7 milliseconds</span><br><span class="line">65.39% &lt;= 8 milliseconds</span><br><span class="line">65.44% &lt;= 9 milliseconds</span><br><span class="line">65.45% &lt;= 10 milliseconds</span><br><span class="line">65.50% &lt;= 11 milliseconds</span><br><span class="line">65.54% &lt;= 12 milliseconds</span><br><span class="line">65.54% &lt;= 13 milliseconds</span><br><span class="line">65.54% &lt;= 14 milliseconds</span><br><span class="line">65.55% &lt;= 15 milliseconds</span><br><span class="line">65.56% &lt;= 16 milliseconds</span><br><span class="line">65.57% &lt;= 17 milliseconds</span><br><span class="line">65.60% &lt;= 18 milliseconds</span><br><span class="line">65.68% &lt;= 19 milliseconds</span><br><span class="line">65.80% &lt;= 20 milliseconds</span><br><span class="line">66.01% &lt;= 21 milliseconds</span><br><span class="line">66.39% &lt;= 22 milliseconds</span><br><span class="line">67.35% &lt;= 23 milliseconds</span><br><span class="line">69.41% &lt;= 24 milliseconds</span><br><span class="line">72.64% &lt;= 25 milliseconds</span><br><span class="line">75.51% &lt;= 26 milliseconds</span><br><span class="line">77.92% &lt;= 27 milliseconds</span><br><span class="line">80.83% &lt;= 28 milliseconds</span><br><span class="line">83.25% &lt;= 29 milliseconds</span><br><span class="line">87.63% &lt;= 30 milliseconds</span><br><span class="line">91.26% &lt;= 31 milliseconds</span><br><span class="line">94.02% &lt;= 32 milliseconds</span><br><span class="line">96.35% &lt;= 33 milliseconds</span><br><span class="line">97.76% &lt;= 34 milliseconds</span><br><span class="line">98.78% &lt;= 35 milliseconds</span><br><span class="line">99.20% &lt;= 36 milliseconds</span><br><span class="line">99.45% &lt;= 37 milliseconds</span><br><span class="line">99.56% &lt;= 38 milliseconds</span><br><span class="line">99.66% &lt;= 39 milliseconds</span><br><span class="line">99.70% &lt;= 40 milliseconds</span><br><span class="line">99.78% &lt;= 41 milliseconds</span><br><span class="line">99.84% &lt;= 42 milliseconds</span><br><span class="line">99.86% &lt;= 43 milliseconds</span><br><span class="line">99.87% &lt;= 44 milliseconds</span><br><span class="line">99.90% &lt;= 45 milliseconds</span><br><span class="line">99.92% &lt;= 46 milliseconds</span><br><span class="line">99.99% &lt;= 47 milliseconds</span><br><span class="line">99.99% &lt;= 48 milliseconds</span><br><span class="line">100.00% &lt;= 48 milliseconds</span><br><span class="line">4753.08 requests per second</span><br></pre></td></tr></table></figure>
<p>显然，插入的速度相比quicklist、linkedlist以及小规模数据量的ziplist时明显慢了许多。并且能看到，随着数据插入越来越多，插入的速度越来越慢，从数万左右的每秒请求数量慢慢下降到最后的几千每秒请求数量。在100000个元素时，内存占用约488kb，即每个元素约5.0字节，空间利用率约60%，可以看到，空间的占用几乎是线性的关系，并且空间利用率反而增加了一些。</p>
<p>在弹出数据时可以看到，速度越来越快，从1k左右上升到最终的数万每秒请求数量。</p>
<p>对于长字符串的插入，先插入100条：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ redis-benchmark -n 100 lpush mylist <span class="string">"mylist str len: 463. Redis is not a plain key-value store, it is actually a data structures server, supporting different kinds of values. What this means is that, while in traditional key-value stores you associated string keys to string values, in Redis the value is not limited to a simple string, but can also hold more complex data structures. The following is the list of all the data structures supported by Redis, which will be covered separately in this tutorial"</span></span><br><span class="line"></span><br><span class="line">====== lpush mylist mylist str len: 463. Redis is not a plain key-value store, it is actually a data structures server, supporting different kinds of values. What this means is that, <span class="keyword">while</span> <span class="keyword">in</span> traditional key-value stores you associated string keys to string values, <span class="keyword">in</span> Redis the value is not limited to a simple string, but can also hold more complex data structures. The following is the list of all the data structures supported by Redis, <span class="built_in">which</span> will be covered separately <span class="keyword">in</span> this tutorial ======</span><br><span class="line">  100 requests completed <span class="keyword">in</span> 0.00 seconds</span><br><span class="line">  50 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">20.00% &lt;= 1 milliseconds</span><br><span class="line">100.00% &lt;= 1 milliseconds</span><br><span class="line">25000.00 requests per second</span><br><span class="line"></span><br><span class="line">$ redis-cli</span><br><span class="line">127.0.0.1:6379&gt; DEBUG OBJECT mylist</span><br><span class="line">Value at:0x7f82e7f03b40 refcount:1 encoding:ziplist serializedlength:1130 lru:475907 lru_seconds_idle:55</span><br><span class="line"></span><br><span class="line">$ redis-benchmark -t lpop -n 100</span><br><span class="line">====== LPOP ======</span><br><span class="line">  100 requests completed <span class="keyword">in</span> 0.00 seconds</span><br><span class="line">  50 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">46.00% &lt;= 1 milliseconds</span><br><span class="line">100.00% &lt;= 1 milliseconds</span><br><span class="line">33333.33 requests per second</span><br></pre></td></tr></table></figure>
<p>可以看出，插入的时间明显比短字符串更多。插入后总共占用了47kb空间，即每个元素约481字节空间，空间利用率约96.3%。</p>
<p>再来看长字符串的批量插入（日志有删减）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">$ redis-benchmark -n 100000 lpush mylist <span class="string">"mylist str len: 463. Redis is not a plain key-value store, it is actually a data structures server, supporting different kinds of values. What this means is that, while in traditional key-value stores you associated string keys to string values, in Redis the value is not limited to a simple string, but can also hold more complex data structures. The following is the list of all the data structures supported by Redis, which will be covered separately in this tutorial"</span></span><br><span class="line"></span><br><span class="line">====== lpush mylist mylist str len: 463. Redis is not a plain key-value store, it is actually a data structures server, supporting different kinds of values. What this means is that, <span class="keyword">while</span> <span class="keyword">in</span> traditional key-value stores you associated string keys to string values, <span class="keyword">in</span> Redis the value is not limited to a simple string, but can also hold more complex data structures. The following is the list of all the data structures supported by Redis, <span class="built_in">which</span> will be covered separately <span class="keyword">in</span> this tutorial ======</span><br><span class="line">  100000 requests completed <span class="keyword">in</span> 361.97 seconds</span><br><span class="line">  50 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">0.34% &lt;= 1 milliseconds</span><br><span class="line">1.22% &lt;= 2 milliseconds</span><br><span class="line">1.84% &lt;= 3 milliseconds</span><br><span class="line">3.02% &lt;= 4 milliseconds</span><br><span class="line">3.97% &lt;= 5 milliseconds</span><br><span class="line">4.91% &lt;= 6 milliseconds</span><br><span class="line">5.91% &lt;= 7 milliseconds</span><br><span class="line">6.47% &lt;= 8 milliseconds</span><br><span class="line">7.25% &lt;= 9 milliseconds</span><br><span class="line">7.78% &lt;= 10 milliseconds</span><br><span class="line">13.51% &lt;= 20 milliseconds</span><br><span class="line">18.07% &lt;= 30 milliseconds</span><br><span class="line">23.39% &lt;= 40 milliseconds</span><br><span class="line">28.43% &lt;= 50 milliseconds</span><br><span class="line">33.09% &lt;= 60 milliseconds</span><br><span class="line">36.63% &lt;= 70 milliseconds</span><br><span class="line">41.06% &lt;= 80 milliseconds</span><br><span class="line">46.23% &lt;= 90 milliseconds</span><br><span class="line">49.85% &lt;= 100 milliseconds</span><br><span class="line">61.87% &lt;= 120 milliseconds</span><br><span class="line">64.51% &lt;= 140 milliseconds</span><br><span class="line">65.13% &lt;= 170 milliseconds</span><br><span class="line">65.46% &lt;= 202 milliseconds</span><br><span class="line">66.86% &lt;= 320 milliseconds</span><br><span class="line">71.61% &lt;= 350 milliseconds</span><br><span class="line">78.91% &lt;= 380 milliseconds</span><br><span class="line">84.36% &lt;= 410 milliseconds</span><br><span class="line">90.07% &lt;= 440 milliseconds</span><br><span class="line">95.08% &lt;= 470 milliseconds</span><br><span class="line">98.34% &lt;= 510 milliseconds</span><br><span class="line">99.45% &lt;= 543 milliseconds</span><br><span class="line">99.80% &lt;= 570 milliseconds</span><br><span class="line">100.00% &lt;= 746 milliseconds</span><br><span class="line">276.26 requests per second</span><br><span class="line"></span><br><span class="line">$ redis-cli</span><br><span class="line">127.0.0.1:6379&gt; DEBUG OBJECT mylist</span><br><span class="line">Value at:0x7f82e7e02660 refcount:1 encoding:ziplist serializedlength:661619 lru:476557 lru_seconds_idle:579</span><br><span class="line"></span><br><span class="line">$ redis-benchmark -t lpop -n 100000</span><br><span class="line">====== LPOP ======</span><br><span class="line">  100000 requests completed <span class="keyword">in</span> 344.83 seconds</span><br><span class="line">  50 parallel clients</span><br><span class="line">  3 bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line">0.31% &lt;= 1 milliseconds</span><br><span class="line">1.17% &lt;= 2 milliseconds</span><br><span class="line">2.41% &lt;= 3 milliseconds</span><br><span class="line">3.35% &lt;= 4 milliseconds</span><br><span class="line">4.14% &lt;= 5 milliseconds</span><br><span class="line">5.10% &lt;= 6 milliseconds</span><br><span class="line">5.84% &lt;= 7 milliseconds</span><br><span class="line">6.73% &lt;= 8 milliseconds</span><br><span class="line">7.50% &lt;= 9 milliseconds</span><br><span class="line">8.19% &lt;= 10 milliseconds</span><br><span class="line">55.85% &lt;= 100 milliseconds</span><br><span class="line">65.55% &lt;= 211 milliseconds</span><br><span class="line">85.84% &lt;= 300 milliseconds</span><br><span class="line">99.40% &lt;= 400 milliseconds</span><br><span class="line">100.00% &lt;= 72866 milliseconds</span><br><span class="line">290.00 requests per second</span><br></pre></td></tr></table></figure>
<p>可以看到，在单个元素比较大时，插入、弹出ziplist会更加的耗时，但是内存总共占用45M，即单个元素占用约472字节内存，内存利用率达到98%。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从上面的试验可以看到，ziplist对空间的利用率非常高，在数据规模比较小时，耗时相对可接受，但是对于元素比较多或者是单个元素比较长时，插入、弹出的耗时非常大。而linkedlist在插入、删除元素时，元素数量、单个元素的长度对耗时影响小（耗时分布比较集中），但是空间利用率比较差，特别是数据规模较小时，空间利用率非常差。而quicklist结合了二者的优点，首先时间消耗上，数据规模对其影响小，其次是空间利用率，因为底层使用了ziplist，所以在小规模数据上空间表现也良好。</p>

    </div>
    
        <!-- css -->
        <style type="text/css">
            .center {
                text-align: center;
            }
            .hidden {
                display: none;
            }
            .donate_bar a.btn_donate{
                display: inline-block;
                width: 82px;
                height: 82px;
                background: url("/images/theme/btn_reward.gif") no-repeat;
                _background: url("/images/theme/btn_reward.gif") no-repeat;

                <!-- http://7xl6z1.com1.z0.glb.clouddn.com/static/images/theme/btn_reward.gif
                     因为本 hexo 生成的博客所用的 theme 的 a:hover 带动画效果，
                     为了在让打赏按钮显示效果正常 而 添加了以下几行 css，
                     嵌入其它博客时不一定要它们。 -->
                -webkit-transition: background 0s;
                -moz-transition: background 0s;
                -o-transition: background 0s;
                -ms-transition: background 0s;
                transition: background 0s;
                <!-- /让打赏按钮的效果显示正常 而 添加的几行 css 到此结束 -->
            }

            .donate_bar a.btn_donate:hover{ background-position: 0px -82px;}
            .donate_bar .donate_txt {
                display: block;
                color: #9d9d9d;
                font: 14px/2 "Microsoft Yahei";
            }
            .bold{ font-weight: bold; }
            .border {
                border-bottom: 2px solid #dbdbdb
            }
        </style>
        <!-- /css -->

        <!-- Donate Module -->
        <div id="donate_module">

        <!-- btn_donate & tips -->
        <div class="border"><br></div><br><br>
        <div id="donate_board" class="donate_bar center">
            <a id="btn_donate" class="btn_donate" target="_self" href="javascript:;" title="Donate 打赏"></a>
            <span class="donate_txt">
                如果对你有帮助，可以赏我一杯咖啡~
            </span>
                
            
        </div>
        <!-- /btn_donate & tips -->

        <!-- donate guide -->
        
        <div id="donate_guide" class="donate_bar center hidden">
            

            <a href="/images/theme/reward_wechat.jpg" title="用微信扫一扫哦~" class="fancybox" rel="article0">
                <img src="/images/theme/reward_wechat.jpg" title="微信打赏 Donate" height="190px" width="auto"/>
            </a>
            
            &nbsp;&nbsp;

            <a href="/images/theme/reward_alipay.jpg" title="用支付宝扫一扫即可~" class="fancybox" rel="article0">
                <img src="/images/theme/reward_alipay.jpg" title="支付宝打赏 Donate" height="190px" width="auto"/>
            </a>

            <span class="donate_txt">
                如果对你有帮助，可以赏我一杯咖啡~
            </span>

        </div>
        <!-- /donate guide -->

        <!-- donate script -->
        <script type="text/javascript">
            document.getElementById('btn_donate').onclick = function() {
                $('#donate_board').addClass('hidden');
            $('#donate_guide').removeClass('hidden');
            }

            function donate_on_web(){
                $('#donate').submit();
            }

            var original_window_onload = window.onload;
            window.onload = function () {
                if (original_window_onload) {
                    original_window_onload();
                }
                document.getElementById('donate_board_wdg').className = 'hidden';
            }
        </script>
        <!-- /donate script -->
    </div>
    <!-- /Donate Module -->
       
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Redis/">Redis</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/笔记/">笔记</a><a href="/tags/redis/">redis</a><a href="/tags/数据结构/">数据结构</a><a href="/tags/quicklist/">quicklist</a><a href="/tags/ziplist/">ziplist</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://blog.liexing.me/2019/12/28/from-ziplist-linkedlist-to-quicklist/" data-title="Redis的List，从linkedlist和ziplist再到quicklist | Liexing&#39;s Blog" data-tsina="1915625641" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 

<div class="next">
<a href="/2019/12/01/Tibetan-Self-driving-Travel-Notes-5/"  title="两人一车，说走就走的西藏自驾游（5）：青海归来">
 <strong>下一篇：</strong><br/> 
 <span>两人一车，说走就走的西藏自驾游（5）：青海归来
</span>
</a>
</div>

</nav>

	

<section id="comments" class="comment">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

</div>  

      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#List的底层编码及演进"><span class="toc-number">1.</span> <span class="toc-text">List的底层编码及演进</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linkedlist"><span class="toc-number">2.</span> <span class="toc-text">linkedlist</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ziplist"><span class="toc-number">3.</span> <span class="toc-text">ziplist</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QuickList"><span class="toc-number">4.</span> <span class="toc-text">QuickList</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#性能对比"><span class="toc-number">5.</span> <span class="toc-text">性能对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#quicklist的性能"><span class="toc-number">5.1.</span> <span class="toc-text">quicklist的性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linkedlist的性能"><span class="toc-number">5.2.</span> <span class="toc-text">linkedlist的性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ziplist的性能"><span class="toc-number">5.3.</span> <span class="toc-text">ziplist的性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">5.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="scusjs" data-width="220" data-height="119" data-theme="medium">
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>
  </div>



  
<div class="categorieslist">
    <p class="asidetitle">分类</p>
        <ul>
        
          
            <li><a href="/categories/Cassandra/" title="Cassandra">Cassandra<sup>2</sup></a></li>
          
        
          
            <li><a href="/categories/Druid/" title="Druid">Druid<sup>6</sup></a></li>
          
        
          
            <li><a href="/categories/Java/" title="Java">Java<sup>3</sup></a></li>
          
        
          
            <li><a href="/categories/Redis/" title="Redis">Redis<sup>1</sup></a></li>
          
        
          
            <li><a href="/categories/建站相关/" title="建站相关">建站相关<sup>1</sup></a></li>
          
        
          
            <li><a href="/categories/杂/" title="杂">杂<sup>7</sup></a></li>
          
        
          
            <li><a href="/categories/深度学习/" title="深度学习">深度学习<sup>3</sup></a></li>
          
        
          
            <li><a href="/categories/笔记/" title="笔记">笔记<sup>3</sup></a></li>
          
        
          
            <li><a href="/categories/算法/" title="算法">算法<sup>1</sup></a></li>
          
        
          
            <li><a href="/categories/统计学习/" title="统计学习">统计学习<sup>6</sup></a></li>
          
        
        </ul>
</div>



  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://yaccc.github.io" target="_blank" title="">浮生若梦</a>
            
          </li>
        
          <li>
            
            	<a href="https://amaoamao.github.io" target="_blank" title="">mBoke</a>
            
          </li>
        
    </ul>
</div>

  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

  
  <div class="tagcloudlist">
    <p class="asidetitle">标签云</p>
    <div class="tagcloudlist clearfix">
       <a href="/tags/Adam/" style="font-size: 10px;">Adam</a> <a href="/tags/BGD/" style="font-size: 10px;">BGD</a> <a href="/tags/Cassandra/" style="font-size: 11.67px;">Cassandra</a> <a href="/tags/Druid/" style="font-size: 16.67px;">Druid</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/LCS/" style="font-size: 10px;">LCS</a> <a href="/tags/Momentum/" style="font-size: 10px;">Momentum</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/NOSQL/" style="font-size: 11.67px;">NOSQL</a> <a href="/tags/SGD/" style="font-size: 10px;">SGD</a> <a href="/tags/Spring-Boot/" style="font-size: 10px;">Spring Boot</a> <a href="/tags/Sytle-Transfer/" style="font-size: 10px;">Sytle Transfer</a> <a href="/tags/Weight-initialization/" style="font-size: 10px;">Weight initialization</a> <a href="/tags/algorithms/" style="font-size: 10px;">algorithms</a> <a href="/tags/bash/" style="font-size: 10px;">bash</a> <a href="/tags/dynamic-programming/" style="font-size: 10px;">dynamic programming</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/k-邻近法/" style="font-size: 11.67px;">k 邻近法</a> <a href="/tags/knn/" style="font-size: 11.67px;">knn</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/macOS/" style="font-size: 10px;">macOS</a> <a href="/tags/parallelStream/" style="font-size: 10px;">parallelStream</a> <a href="/tags/quicklist/" style="font-size: 10px;">quicklist</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/stream/" style="font-size: 10px;">stream</a> <a href="/tags/utf8/" style="font-size: 10px;">utf8</a> <a href="/tags/utf8mb4/" style="font-size: 10px;">utf8mb4</a> <a href="/tags/ziplist/" style="font-size: 10px;">ziplist</a> <a href="/tags/内存模型/" style="font-size: 10px;">内存模型</a> <a href="/tags/分布式/" style="font-size: 18.33px;">分布式</a> <a href="/tags/多线程/" style="font-size: 10px;">多线程</a> <a href="/tags/实时计算/" style="font-size: 16.67px;">实时计算</a> <a href="/tags/异常处理/" style="font-size: 10px;">异常处理</a> <a href="/tags/异常表/" style="font-size: 10px;">异常表</a> <a href="/tags/感知机/" style="font-size: 10px;">感知机</a> <a href="/tags/数据结构/" style="font-size: 10px;">数据结构</a> <a href="/tags/最大熵模型/" style="font-size: 10px;">最大熵模型</a> <a href="/tags/朴素贝叶斯/" style="font-size: 10px;">朴素贝叶斯</a> <a href="/tags/机器学习/" style="font-size: 16.67px;">机器学习</a> <a href="/tags/杂/" style="font-size: 16.67px;">杂</a> <a href="/tags/梯度下降/" style="font-size: 10px;">梯度下降</a> <a href="/tags/深度学习/" style="font-size: 13.33px;">深度学习</a> <a href="/tags/源码分析/" style="font-size: 10px;">源码分析</a> <a href="/tags/生成/" style="font-size: 10px;">生成</a> <a href="/tags/生活/" style="font-size: 15px;">生活</a> <a href="/tags/笔记/" style="font-size: 20px;">笔记</a> <a href="/tags/统计学习/" style="font-size: 16.67px;">统计学习</a> <a href="/tags/编码/" style="font-size: 10px;">编码</a> <a href="/tags/自驾/" style="font-size: 15px;">自驾</a> <a href="/tags/调参/" style="font-size: 11.67px;">调参</a> <a href="/tags/跨域/" style="font-size: 10px;">跨域</a> <a href="/tags/踩坑日志/" style="font-size: 10px;">踩坑日志</a> <a href="/tags/逻辑斯谛回归/" style="font-size: 10px;">逻辑斯谛回归</a> <a href="/tags/配置/" style="font-size: 10px;">配置</a> <a href="/tags/风格迁移/" style="font-size: 10px;">风格迁移</a>
    </div>
  </div>


  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="//widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=1915625641&verifier=00e07be0&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello, I&#39;m Liexing in UCAS. <br/>
			Stay hungry. Stay foolish.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/scusjs" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/scusjs" target="_blank" class="icon-github" title="github"></a>
		
		
		
		<a href="https://twitter.com/scusjs" target="_blank" class="icon-twitter" title="twitter"></a>
		
		
		
		<a href="https://www.linkedin.com/in/shenjinsheng" target="_blank" class="icon-linkedin" title="linkedin"></a>
		
		
		<a href="https://www.douban.com/people/58108093" target="_blank" class="icon-douban" title="豆瓣"></a>
		
		
		<a href="http://www.zhihu.com/people/scusjs" target="_blank" class="icon-zhihu" title="知乎"></a>
		
		
		
		<a href="mailto:i@liexing.me" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 
<span id="busuanzi_container_site_pv">
  &nbsp<i class="fa fa-eye"></i> <span id="busuanzi_value_site_pv"><i class="fa fa-spinner fa-spin"></i></span>
</span>
<span id="busuanzi_container_site_uv">
  &nbsp<i class="fa fa-user"></i> <span id="busuanzi_value_site_uv"><i class="fa fa-spinner fa-spin"></i></span>
</span>
2023 
		
		<a href="/about" target="_blank" title="liexing">liexing</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script async src="/js/ones.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>




<script type="text/javascript">

var disqus_shortname = 'liexing';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<span style="display:none"><script src="https://s11.cnzz.com/z_stat.php?id=1256113107&web_id=1256113107" language="JavaScript"></script></span>


<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
